<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>Offloading</title>
	<link href="../css/style.css" rel="stylesheet" type="text/css" media="screen" />
	<link href="../css/print.css" rel="stylesheet" type="text/css" media="print" />
</head>

<body>
	<div id="page">
		<div id="contentwrapper">
			<div id="sidebar_navigation" class="sidebar">
				<div class="left_sidebar_menu">
					<div class="left_sidebar_menu_button">
						<a href="index.html">Inicio</a>
					</div>
					<div class="left_sidebar_menu_selected">
						<a href="documentation.html">Documentación</a>
					</div>
					<div class="left_sidebar_menu_button">
						<a href="download.html">Descargar</a>
					</div>
					<div class="left_sidebar_menu_button">
						<a href="faq.html">FAQ</a>
					</div>
					<div class="left_sidebar_menu_button">
						<a href="https://github.com/NICMx/NAT64/issues" target="_blank">
							Reportar un Bug
						</a>
					</div>
					<div class="left_sidebar_menu_button">
						<a href="about.html">Acerca de ...</a>
					</div>
					<div class="left_sidebar_menu_button">
						<a href="contact.html">Contacto</a>
					</div>
				</div>
			</div>
			<div id="content">
				<div class="worklogo">
					<a href="index.html"><img src="../images/jool.png" alt="logo-jool" /></a>
				</div>
				<div class="workarea">
					<div class="content_text">

<p><a href="documentation.html">Documentación</a> &gt; <a href="documentation.html#otros">Otros</a> &gt; Offloading</p>

<h1 id="offload">Offload</h1>

<h2 id="ndice">Índice</h2>

<ol>
  <li><a href="#teoria">Teoría</a></li>
  <li><a href="#practica">Práctica</a></li>
</ol>

<h2 id="teora">Teoría</h2>

<p>Offloading es una técnica orientada a optimizar el rendimiento de la red. Nació de la observación de que un solo paquete grande es significantemente más rapido de procesar que muchos pequeños, la idea es combinar muchos de ellos</p>

<p>Offloading is a technique meant to optimize network throughput. Born from the observation that a single large packet is significantly faster to process than several small ones, the idea is to combine several of them from a common stream on reception, and then pretend, to the eyes of the rest of the system, that the new packet was the one received from the cord all along.</p>

<p>Aquí tenemos un ejemplo visual. Así es como los paquetes son procesados normalmente (sin offloading):</p>

<p><img src="../images/offload-none.svg" alt="Fig.1 - No offload" /></p>

<p>(Por el momento, asume que la capa de Internet soporta IPv4.)</p>

<p>Hay dos streams aquí. El amarillo consiste de tres paquetes muy pequeños:</p>

<ol>
  <li>1st packet: bytes 0 through 9.</li>
  <li>2nd packet: bytes 10 to 29.</li>
  <li>3rd packet: bytes 30 to 39.</li>
</ol>

<p>Y el azul contiene unos paquetes más largos:</p>

<ol>
  <li>bytes 0 to 599</li>
  <li>bytes 600 to 1199</li>
  <li>bytes 1200 to 1799</li>
</ol>

<p>Hay muchas manetas de implementar offloading. Abajo se encuentra ilustrada una versión simplificada de lo que una NIC(interfáz de red) quizá podria hacer, en lugar de lo de arriba:</p>

<p><img src="../images/offload-right.svg" alt="Fig.2 - Offload done right" /></p>

<p>Simplemente poner, muchos paquetes continuos</p>

<p>Puesto simplemente, muchos paquetes continuos son unidos en uno equivalente y mas grande. La tarjeta podria por ejemplo hacer esto uniendo fragmentos IP o incluso segmentos TCP (aunque TCP se encuentre 2 capas arriba). No importa mientras el cambio sea completamente transparente por lo menos en lo que a transferencia de datos se refiere.</p>

<p>Y si, ahora estamos lidiando con piezas de datos más pesadas, pero a decir verdad, la mayor parte de la acitivdad de las capas de Internet y Transporte recae en los primeros bytes de cada paquete (ej. los encabezados). Asi que mayormente conseguimos procesar n paquetes por el precio de uno.</p>

<p>Esto esta excelente, pero empiezas a tener problemas en caso de que el sistema tenga que redireccionar los datos (en lugar de comsumirlos). Digamos el hardware tiene una <a href="http://es.wikipedia.org/wiki/Unidad_m%C3%A1xima_de_transferencia">Unidad de Transmisión Máxima (MTU)</a> de 1500; esto es lo que pasa:</p>

<p><img src="../images/offload-router.svg" alt="Fig.3 - Offload on a router" /></p>

<p>En el paso 1 sucede la agregación, lo que hace le paso 2 muy rápido, pero como el paquete ensamblado del flujo de datos azul es muy grande para la interfaz de salida (tamaño 1800 &gt; max 1500), el paquete se fragmenta en el paso 3, lo cual es ineficiente.</p>

<p>Mas importante, si el emisor realizó un <a href="http://en.wikipedia.org/wiki/Path_MTU_Discovery">path MTU discovery</a>, entonces el MTU óptimo computado se perderá en el paso 1 (por que no esta almanecado en el paquete; es indicado por su tamaño, el cual es modificado por el paso1). Por que el parámetro “Don’t Fragment” del paquete estará encendido, entonces el paquete eventualmente e irremediablemente sera desechado tan pronto llegue a un MTU menor. Por lo tanto, hemos creado un hoyo negro.</p>

<p>(Bueno, no completamente. Un cierto numero de condiciones son requeridas por la Interfaz de red(NIC) para ejecutar el offloading. Puede que en algunas ocasiones raras y aleatorias estas condiciones no se cumplan, asi que ciertos paquetes ocasionalmente no serán agregados, y asi evitan el hoyo. Si tu protocolo de transporte reintenta suficientemente, en lugar de tener una denegación de servicio completa, tienes una red extrema - <strong>EXTREMAMENTE</strong> - lenta.)</p>

<p>Cuando la maquina de redireccionamiento es un router IPv6 (o, en el caso de Jool, un SIIT/NAT64 traduciendo de IPv4 a 6), esto es un problema mas inmediato por que los <em>routers IPv6 no estan pensados para fragmentar paquetes</em>  (se espera que solo desechen el paquete y devuelvan un mensaje de error ICMP). Así que tu paquete se perdera en el paso 3 <em>incluso si el parámetro “Don’t Fragment” del paquete original no fue indicado</em>.</p>

<p>Si estas ejecutando Jool en una maquina virtual huesped, algo importante que debes mantener en mente es que quizá prefieras o tambien tengas que deshabilitar los offloads en el enlace de subida del <a href="http://es.wikipedia.org/wiki/Hipervisor">Host de la maquina virtual</a>.</p>

<p>Y eso es todo. Offloading para nodos finales es gandioso, para los routers es un problema.</p>

<h2 id="prctica">Práctica</h2>

<p>Así que, si quieres ejecutar Jool, debes de desactivar el offloading. Así es como comenzamos a hacerlo (el alcance puede variar):</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo apt-get install ethtool</code></pre></div>

<p>Luego aplica esto a toda interfáz relevante:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> gro off</code></pre></div>

<p>“gro” es por sus siglas en inglés “Generic Receive Offload”. Actualmente no sabemos con certeza por que no tenemos que desactivar lro (Large receive offload), gso (Generic segmentation offload) y quizá otros (vea <code>man ethtool</code>). Si no estás seguro, yo diria que debes ir a lo seguro y deshacerte de todas las variantes que veas:</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> tso off
<span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> ufo off
<span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> gso off
<span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> gro off
<span class="nv">$ </span>sudo ethtool --offload <span class="o">[</span>your interface here<span class="o">]</span> lro off</code></pre></div>

<p>(Si puedes iluminarnos mas en cuanto a este tema, por favor notificanos - <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#106;&#111;&#111;&#108;&#064;&#110;&#105;&#099;&#046;&#109;&#120;">&#106;&#111;&#111;&#108;&#064;&#110;&#105;&#099;&#046;&#109;&#120;</a>.)</p>

<p>Algunas veces ethtool asegura que no puede cambiar algunas de las variantes, pero ten en cuenta que es usualmente por que no esta soportado y por lo tanto no estaba en un principio. Verifica tu configuración utilizando</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>sudo ethtool --show-offload <span class="o">[</span>your interface here<span class="o">]</span></code></pre></div>

<p>Suerte!</p>


					</div>
				</div>
			</div>
			<div id="language_selector">
				
					<a href="../en/offloading.html">en</a>
				
				|
				
					<span class="selected">es</span>
				
			</div>
			<div style="clear: both;">&nbsp;</div>
		</div>
	</div>

	<div id="footer">
		<div class="logo-tec"><a href="http://www.itesm.mx"><img src="../images/logo-tec.png" alt="logo-tec" /></a></div>
		<div class="logo-nic"><a href="http://www.nicmexico.mx/"><img src="../images/logo-nic.png" alt="logo-nic" /></a></div>
		<p class="legal">&copy;Jool 2015</p>
	</div>

	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'UA-44741331-2', 'jool.mx');
	  ga('send', 'pageview');

	</script>
</body>
</html>
