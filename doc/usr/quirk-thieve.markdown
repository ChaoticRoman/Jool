---
layout: documentation
title: Documentation - Quirk-Thievery
---

# Quirk: Thievery of Packets

(Please note: This is all based on personal research. The Linux Kernel is a massive behemoth and as such, I might have overlooked some detail. If you know of some feature that trumps the reasoning exposed here, we'd love to hear it - [jool@nic.mx](mailto:jool@nic.mx))

If Jool gets to translate a packet, then the packet skips a lot of Linux's network infrastructure.

This is Linux's network pipeline, as we understand it. Packets follow the following roads while traversing the kernel:

![Fig.1 - No Jool](images/quirk2-normal.png)

When the packet is intended for the local host, it stays on the "Local process". When it is generated by the Linux machine, it starts on the "Local process". When the node is a router, then the packet skips the upper boxes.

(If you're still completely lost on what is going on, you might want to find generic documentation on Netfilter.)

When one wants to inject NAT64 into Linux, it is tempting to assume it is going to behave the same as NAT. One could just drop DNAT and modprobe Jool instead:

![Fig.2 - Naive Jool](images/quirk2-fake-jool.png)

However, we ended up doing this instead:

![Fig.3 - Actual Jool](images/quirk2-actual-jool.png)

If Jool detects it is supposed to translate the packet (i.e. the packet is headed to one of Jool's pools) then Jool _steals_ it. The packet skips the other Prerouting hooks, the routing box and any possibility of reaching local processes, and goes directly to postrouting.

There are two reasons why this is done, the second one being more decisive:

## 1: The defrag module

To avoid fragmentation during IPv4 pre-routing. More info [here](quirk-iptables.html).

## 2: Netfilter assumes no layer-3 translation

The thing with the above diagrams is that one would hope that the boxes were protocol-independent. For example, once a packet abandons the Prerouting box, one would wish that the Routing box would read the packet and figure whether it's supposed to look into the IPv4 routing tables or the IPv6 ones.

However, that is not the case; the nature of NAT64 is a little too intrusive for Netfilter. There is one road map inside the kernel **per** network protocol. If an IPv4 packet enters the Prerouting chain, then an IPv4 packet is expected to come out of the chain. This is very easy to prove, so I'll waste a bit of space here:

(The following code was extracted from the 3.4.62 version of the kernel.)

The IPv4 PREROUTING modules are called during the `ip_rcv()` function from ip_input.c:

{% highlight c %}
int ip_rcv(...)
{
	...
	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, NULL,
		       ip_rcv_finish);
}
{% endhighlight %}

The `NF_HOOK` macro iterates over every module and calls `ip_rcv_finish()` after they have all returned success. The first thing that `ip_rcv_finish` does is

{% highlight c %}
const struct iphdr *iph = ip_hdr(skb);
{% endhighlight %}

(Where `skb` is the packet)

That is, it _assumes_ there's an IPv4 header in the packet and obtains it to handle several of its fields. If it finds an IPv6 header instead, undefined behavior will happen.

Conversely, if the packet is IPv6, different (yet somewhat mirrored) functions are called:

{% highlight c %}
int ip6_input(struct sk_buff *skb)
{
	return NF_HOOK(NFPROTO_IPV6, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
		       ip6_input_finish);
}
{% endhighlight %}

And somewhere inside of `ip6_input_finish()`:

{% highlight c %}
	const struct ipv6hdr *hdr;
	hdr = ipv6_hdr(skb);
{% endhighlight %}

So with or without defrag dilemma, Jool absolutely has to prevent the kernel from seeing the mangled packets.

