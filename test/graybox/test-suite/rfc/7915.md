---
---

<style type="text/css">
	pre {
		margin-left: 4em;
	}
	.highlighter-rouge {
		background-color: #E0E0E0;
	}
	p {
		font-size: 85%;
	}
</style>

# Graybox Tests: RFC 7915

## Part 1: Requirements Analysis

Glossary:

- "Not a requirement": Statement is irrelevant to the implementation, so it should yield no test.
- "Too trivial": Requirement is so basic it's essentially already addressed in many other tests.
- "Untestable": Requirement cannot be tested by the graybox framework as currently implemented. (Usually silent packet drops (because Graybox needs responses), emerging fragment identifiers (because of randomness) and checksums (because of fragment identifier randomness).)
- "Fragmentation Needed": ICMPv4 3/4
- "Packet too Big": ICMPv6 2/0

### 1.2. Applicability and Limitations

	This document specifies the translation algorithms between IPv4
	packets and IPv6 packets.

Not a requirement.

	As with [RFC6145], the translating function specified in this
	document does not translate any IPv4 options,

Test: Packet with IPv4 options -> Normal IPv6 packet ([aa](#aa))

	and it does not
	translate IPv6 extension headers except the Fragment Header.

Test: Packet with IPv6 extension headers before the fragment header -> Normal IPv4 packet ([ab](#ab))<br />
Test: Packet with IPv6 extension headers after the fragment header -> ICMPv6 error 1/1 ([ac](#ac))<br />
See [Simple Extension Headers](https://github.com/NICMx/Jool/wiki/RFC-7915-Review#simple-extension-headers).

	The issues and algorithms in the translation of datagrams containing
	TCP segments are described in [RFC5382].

Not a requirement.

	Fragmented IPv4 UDP packets that do not contain a UDP checksum (i.e.,
	the UDP checksum field is zero) are not of significant use on the
	Internet, and in general will not be translated by the IP/ICMP
	translator (Section 4.5).

Test: Fragmented UDP zero checksum -> Drop ([ec](#ec))

	However, when the translator is configured
	to forward the packet without a UDP checksum, the fragmented IPv4 UDP
	packets will be translated.

Requirement makes no sense. (How to compute a checksum out of a fragmented UDP packet?)<br />
Related: [Fragmented UDP Checksum Zero](https://github.com/NICMx/Jool/wiki/RFC-7915-Review#fragmented-udp-checksum-zero)

	Fragmented ICMP/ICMPv6 packets will not be translated by IP/ICMP
	translators.

Untestable.

	The IP/ICMP header translation specified in this document is
	consistent with requirements of multicast IP/ICMP headers.  However,
	IPv4 multicast addresses [RFC5771] cannot be mapped to IPv6 multicast
	addresses [RFC3307] based on the unicast mapping rule [RFC6052].  An
	example of experiments of the multicast address mapping can be found
	in [RFC6219].

Not a requirement.

### 1.3. Stateless vs. Stateful Mode

	An IP/ICMP translator has two possible modes of operation: stateless
	and stateful [RFC6144].  In both cases, we assume that a system (a
	node or an application) that has an IPv4 address but not an IPv6
	address is communicating with a system that has an IPv6 address but
	no IPv4 address, or that the two systems do not have contiguous
	routing connectivity, or they might have contiguous routing
	connectivity but are interacting via masking addresses (i.e.,
	hairpinning) [RFC4787], and hence are forced to have their
	communications translated.

Test: Hairpinning ([ga](#ga))

	In the stateless mode, an IP/ICMP translator will convert IPv4
	addresses to IPv6 and vice versa solely based on the configuration of
	the stateless IP/ICMP translator and information contained within the
	packet being translated.  For example, for the default behavior
	defined in [RFC6052], a specific IPv6 address range will represent
	IPv4 systems (IPv4-converted addresses), and the IPv6 systems have
	addresses (IPv4-translatable addresses) that can be algorithmically
	mapped to a subset of the service provider's IPv4 addresses.  Other
	stateless translation algorithms are defined in Section 6.  The
	stateless translator does not keep any dynamic session or binding
	state, thus there is no requirement that the packets in a single
	session or flow traverse a single translator.

	In the stateful mode, a specific IPv6 address range (consisting of
	IPv4-converted IPv6 addresses) will typically represent IPv4 systems.
	The IPv6 nodes may use any IPv6 addresses [RFC4291] except in that
	range.  A stateful IP/ICMP translator continuously maintains a
	dynamic translation table containing bindings between the IPv4 and
	IPv6 addresses, and likely also the Layer-4 identifiers, that are
	used in the translated packets.  The exact address translations of
	any given packet thus become dependent on how packets belonging to
	the same session or flow have been translated.  For this reason,
	stateful translation generally requires that all packets belonging to
	a single flow must traverse the same translator.

	In order to be able to successfully translate a packet from IPv4 to
	IPv6 or vice versa, the translator must implement an address mapping
	algorithm.  This document does not specify any such algorithms,
	instead these are referenced from Section 6.

Not a requirement.

(Or more like "tests postponed until corresponding RFC analysis.")

### 1.4. Path MTU Discovery and Fragmentation

	Due to the different sizes of the IPv4 and IPv6 header, which are 20+
	octets and 40 octets respectively, handling the maximum packet size
	is critical for the operation of the IPv4/IPv6 translator.  There are
	three mechanisms to handle this issue: path MTU discovery (PMTUD),
	fragmentation, and transport-layer negotiation such as the TCP
	Maximum Segment Size (MSS) option [RFC6691].

Not a requirement.

	Note that the
	translator MUST behave as a router, i.e., the translator MUST send a
	Packet Too Big error message or fragment the packet when the packet
	size exceeds the MTU of the next-hop interface.

Test: IPv4 DF set, large packet -> Fragmentation Needed ([ca](#ca))<br />
Test: IPv4 DF unset, large packet -> IPv6 fragments ([cc](#cc))<br />
Test: IPv6, large packet -> Packet too Big ([cg](#cg))

	Don't Fragment, ICMP Packet Too Big, and packet fragmentation are
	discussed in Sections 4 and 5 of this document.  The reassembling of
	fragmented packets in the stateful translator is discussed in
	[RFC6146], since it requires state maintenance in the translator.

Not a requirement.

### 4. Translating from IPv4 to IPv6

	When an IP/ICMP translator receives an IPv4 datagram addressed to a
	destination towards the IPv6 domain, it translates the IPv4 header of
	that packet into an IPv6 header.  The original IPv4 header on the
	packet is removed and replaced by an IPv6 header,

Too trivial.

	and the transport
	checksum is updated as needed, if that transport is supported by the
	translator.

Untestable.

	The data portion of the packet is left unchanged.  The
	IP/ICMP translator then forwards the packet based on the IPv6
	destination address.

Too trivial.

	Path MTU discovery is mandatory in IPv6, but it is optional in IPv4.
	IPv6 routers never fragment a packet -- only the sender can do
	fragmentation.

Not a requirement.

	When an IPv4 node performs path MTU discovery (by setting the Don't
	Fragment (DF) bit in the header), path MTU discovery can operate end-
	to-end, i.e., across the translator.  In this case, either IPv4 or
	IPv6 routers (including the translator) might send back ICMP Packet
	Too Big messages to the sender.  When the IPv6 routers send these
	ICMPv6 errors, they will pass through a translator that will
	translate the ICMPv6 error to a form that the IPv4 sender can
	understand.

Test: Packet too Big -> Fragmentation Needed ([da](#da))<br />
Test: DF set, large packet -> Fragmentation Needed ([ca](#ca))

	As a result, an IPv6 Fragment Header is only included if
	the IPv4 packet is already fragmented.

> Note: This requirement is bewildering. Is it seriously the only sentence in the entire RFC talking about DF-enabled IPv4 fragments? All right, I'll take it.

Test: IPv4 fragment, DF set -> IPv6 fragment. (TODO)

	However, when the IPv4 sender does not set the DF bit, the translator
	MUST ensure that the packet does not exceed the path MTU on the IPv6
	side.  This is done by fragmenting the IPv4 packet (with Fragment
	Headers) so that it fits in 1280-byte IPv6 packets, since that is the
	minimum IPv6 MTU.  The IPv6 Fragment Header has been shown to cause
	operational difficulties in practice due to limited firewall
	fragmentation support, etc.  In an environment where the network
	owned/operated by the same entity that owns/operates the translator,
	the translator MUST provide a configuration function for the network
	administrator to adjust the threshold of the minimum IPv6 MTU to a
	value that reflects the real value of the minimum IPv6 MTU in the
	network (greater than 1280 bytes).  This will help reduce the chance
	of including the Fragment Header in the packets.

Implementation flawed ([#136](https://github.com/NICMx/Jool/issues/136)), so test postponed.

	When the IPv4 sender does not set the DF bit, the translator MUST NOT
	include the Fragment Header for the non-fragmented IPv6 packets.

Related: [DF and the Fragment Header](https://github.com/NICMx/Jool/wiki/RFC-7915-Review#df-and-the-fragment-header)

Test: DF set, packet <= 1280 -> no fragment header ([cb](#cb))<br />
Test: DF unset, packet <= 1280 -> no fragment header ([cd](#cd))<br />
Test: DF set, packet > 1280 -> Fragmentation Needed ([ca](#ca))<br />
Test: DF unset, packet > 1280 -> fragments ([cc](#cc))<br />
Test: DF set, fragment <= 1280 -> fragment (TODO)<br />
Test: DF unset, fragment <= 1280 -> fragment ([ce](#ce))<br />
Test: DF set, fragment > 1280 -> Fragmentation Needed (TODO)<br />
Test: DF unset, fragment > 1280 -> fragments ([cf](#cf))<br />

	The rules in Section 4.1 ensure that when packets are fragmented,
	either by the sender or by IPv4 routers, the low-order 16 bits of the
	fragment identification are carried end-to-end, ensuring that packets
	are correctly reassembled.

Test: IPv4 fragment -> IPv6 fragment, same identification number ([ce](#ce))

	Other than the special rules for handling fragments and path MTU
	discovery, the actual translation of the packet header consists of a
	simple translation as defined below.

Not a requirement.

	Note that ICMPv4 packets
	require special handling in order to translate the content of ICMPv4
	error messages

Test: ICMPv4 error containing IPv4 packet -> ICMPv6 error containing IPv6 packet ([ba](#ba))

	and also to add the ICMPv6 pseudo-header checksum.

Untestable.

	The translator SHOULD make sure that the packets belonging to the
	same flow leave the translator in the same order in which they
	arrived.

Not really a requirement, also essentially untestable.

### 4.1. Translating IPv4 Headers into IPv6 Headers

	If the DF flag is not set and the IPv4 packet will result in an IPv6
	packet larger than a user-defined length (hereinafter referred to as
	"lowest-ipv6-mtu", and which defaults to 1280 bytes), the packet
	SHOULD be fragmented so that the resulting IPv6 packet (with Fragment
	Header added to each fragment) will be less than or equal to lowest-
	ipv6-mtu, For example, if the packet is fragmented prior to the
	translation, the IPv4 packets should be fragmented so that their
	length, excluding the IPv4 header, is at most 1232 bytes (1280 minus
	40 for the IPv6 header and 8 for the Fragment Header).  The
	translator MUST provide a configuration function for the network
	administrator to adjust the threshold of the minimum IPv6 MTU to a
	value greater than 1280 bytes if the real value of the minimum IPv6
	MTU in the network is known to the administrator.  The resulting
	fragments are then translated independently using the logic described
	below.

Implementation flawed ([#136](https://github.com/NICMx/Jool/issues/136)), so test postponed.

	If the DF bit is set and the MTU of the next-hop interface is less
	than the total length value of the IPv4 packet plus 20, the
	translator MUST send an ICMPv4 "Fragmentation Needed" error message
	to the IPv4 source address.

Test: DF set, large packet -> Fragmentation Needed ([ca](#ca))

	<Bunch of fields>

Most of these are trivial, and I've decided to postpone all of it.

### 4.2. Translating ICMPv4 Headers into ICMPv6 Headers

	All ICMPv4 messages that are to be translated require that the ICMPv6
	checksum field be calculated as part of the translation since ICMPv6,
	unlike ICMPv4, has a pseudo-header checksum just like UDP and TCP.

Untestable.

	In addition, all ICMPv4 packets MUST have the Type translated and,

Postponed.

	for ICMPv4 error messages, the included IP header also MUST be
	translated.

Test: ICMPv4 error containing IPv4 packet -> ICMPv6 error containing IPv6 packet ([ba](#ba))

	The actions needed to translate various ICMPv4 messages are as
	follows:
	<Bunch of types and codes>

Postponed.

### 4.3. Translating ICMPv4 Error Messages into ICMPv6

	There are some differences between the ICMPv4 and the ICMPv6 error
	message formats as detailed above.  The ICMP error messages
	containing the packet in error MUST be translated just like a normal
	IP packet (except the TTL value of the inner IPv4/IPv6 packet).  If
	the translation of this "packet in error" changes the length of the
	datagram, the Total Length field in the outer IPv6 header MUST be
	updated.

All of these tests are ICMPv4 error containing IPv4 packet -> ICMPv6 error (TTL - 1) containing IPv6 packet (TTL - 0):<br />
Test: ICMPv4 error sized 400 (20 + 8 + 20 + 352) -> ICMPv6 error sized 440 (40 + 8 + 40 + 352) (normal case) ([ba](#ba))<br />
Test: ICMPv4 error sized 1500 (20 + 8 + 20 + 1452) -> ICMPv6 error sized 1280 (40 + 8 + 40 + 1192) (normal case, result truncated due to ICMP fragmentation preventer) ([bb](#bb))<br />
Test: ICMPv4 error sized 1280 (20 + 8 + 20 + 1232) -> ICMPv6 error sized 1280 (40 + 8 + 40 + 1192) (no datagram size change due to ICMP truncation) ([bc](#bc))

> By the way: There's no "Total Length" field in the IPv6 header.

	The translation of the inner IP header can be done by invoking the
	function that translated the outer IP headers.  This process MUST
	stop at the first embedded header and drop the packet if it contains
	more embedded headers.

Test: ICMPv4 error containing ICMPv4 error. (Untestable; ICMP errors do not yield different ICMP errors.)

### 4.4. Generation of ICMPv4 Error Message

	If the IPv4 packet is discarded, then the translator SHOULD be able
	to send back an ICMPv4 error message to the original sender of the
	packet, unless the discarded packet is itself an ICMPv4 error
	message.  The ICMPv4 message, if sent, has a Type of 3 (Destination
	Unreachable) and a Code of 13 (Communication Administratively
	Prohibited), unless otherwise specified in this document or in
	[RFC6146].  The translator SHOULD allow an administrator to configure
	whether the ICMPv4 error messages are sent, rate-limited, or not
	sent.

Off a quick `Ctrl+F`, these are the only unspecified ICMPv4 errors:

	1.  Dropping the packet and generating a system management event that
	specifies at least the IP addresses and port numbers of the
	packet.

Test: UDP checksum zero + `amend-udp-checksum-zero` disabled -> ICMP error ([ea](#ea))<br />

	A stateless translator cannot compute the UDP checksum of
	fragmented packets, so when a stateless translator receives the
	first fragment of a fragmented UDP IPv4 packet and the checksum
	field is zero, the translator SHOULD drop the packet

Test: Fragmented UDP checksum zero -> ICMP error ([ec](#ec))<br />

> TODO I will need to re-read the entire RFC again (and even the code) and search for more. I've already done this several times (including right now), so I'll wait a bit in case I find yet another similar requirement, so I can kill two birds with one stone.

### 4.5. Transport-Layer Header Translation

	If the address translation algorithm is not checksum neutral (see
	Section 4.1 of [RFC6052]), the recalculation and updating of the
	transport-layer headers that contain pseudo-headers need to be
	performed.  Translators MUST do this for TCP and ICMP packets and for
	UDP packets that contain a UDP checksum (i.e., the UDP checksum field
	is not zero).

Untestable.

	For UDP packets that do not contain a UDP checksum (i.e., the UDP
	checksum field is zero), the translator SHOULD provide a
	configuration function to allow:

	1.  Dropping the packet and generating a system management event that
	    specifies at least the IP addresses and port numbers of the
	    packet.

Test: UDP checksum zero + `amend-udp-checksum-zero` disabled -> ICMP error ([ea](#ea))

	2.  Calculating an IPv6 checksum and forwarding the packet (which has
	    performance implications).

Test: UDP checksum zero + `amend-udp-checksum-zero` enabled -> Translation ([eb](#eb))

	A stateless translator cannot compute the UDP checksum of
	fragmented packets, so when a stateless translator receives the
	first fragment of a fragmented UDP IPv4 packet and the checksum
	field is zero, the translator SHOULD drop the packet and generate
	a system management event that specifies at least the IP
	addresses and port numbers in the packet.

Test: Fragmented UDP checksum zero -> ICMP error ([ec](#ec))

	    For a stateful translator, the handling of fragmented UDP IPv4
	    packets with a zero checksum is discussed in [RFC6146],
	    Section 3.4.

Not a requirement.

	Other transport protocols (e.g., the Datagram Congestion Control
	Protocol (DCCP)) are OPTIONAL to support.  In order to ease debugging
	and troubleshooting, translators MUST forward all transport protocols
	as described in the "Next Header" step of Section 4.1.

Test: IPv4 containing garbage transport -> IPv6 containing garbage transport ([fa](#fa))

### 4.6. Knowing When to Translate

	If the IP/ICMP translator also provides a normal forwarding function,
	and the destination IPv4 address is reachable by a more specific
	route without translation, the translator MUST forward it without
	translating it.  Otherwise, when an IP/ICMP translator receives an
	IPv4 datagram addressed to an IPv4 destination representing a host in
	the IPv6 domain, the packet MUST be translated to IPv6.

Untestable.

### 5. Translating from IPv6 to IPv4

	When an IP/ICMP translator receives an IPv6 datagram addressed to a
	destination towards the IPv4 domain, it translates the IPv6 header of
	the received IPv6 packet into an IPv4 header.  The original IPv6
	header on the packet is removed and replaced by an IPv4 header.

Too trivial.

	Since the ICMPv6 [RFC4443], TCP [RFC793], UDP [RFC768], and DCCP
	[RFC4340] headers contain checksums that cover the IP header, if the
	address mapping algorithm is not checksum neutral, the checksum MUST
	be evaluated before translation and the ICMP and transport-layer
	headers MUST be updated.

Untestable.

	The data portion of the packet is left
	unchanged.  The IP/ICMP translator then forwards the packet based on
	the IPv4 destination address.

Too trivial.

	There are some differences between IPv6 and IPv4 (in the areas of
	fragmentation and the minimum link MTU) that affect the translation.
	An IPv6 link has to have an MTU of 1280 bytes or greater.  The
	corresponding limit for IPv4 is 68 bytes.  Path MTU discovery across
	a translator relies on ICMP Packet Too Big messages being received
	and processed by IPv6 hosts.

	The difference in the minimum MTUs of IPv4 and IPv6 is accommodated
	as follows:

Not a requirement.

	o  When translating an ICMPv4 "Fragmentation Needed" packet, the
	   indicated MTU in the resulting ICMPv6 "Packet Too Big" will never
	   be set to a value lower than 1280.  This ensures that the IPv6
	   nodes will never have to encounter or handle Path MTU values lower
	   than the minimum IPv6 link MTU of 1280.  See Section 4.2.

Test: Fragmentation Needed < 1280 -> Packet Too Big = 1280 ([db](#db))

	o  When the resulting IPv4 packet is smaller than or equal to 1260
	   bytes, the translator MUST send the packet with a cleared Don't
	   Fragment bit.  Otherwise, the packet MUST be sent with the Don't
	   Fragment bit set.  See Section 5.1.

Test: IPv6 packet length <= 1280 -> DF disabled ([ci](#ci))<br />
Test: IPv4 packet length > 1280 -> DF enabled ([ch](#ch))

	This approach allows Path MTU Discovery to operate end-to-end for
	paths whose MTU are not smaller than the minimum IPv6 MTU of 1280
	(which corresponds to an MTU of 1260 in the IPv4 domain).  On paths
	that have IPv4 links with MTU < 1260, the IPv4 router(s) connected to
	those links will fragment the packets in accordance with Section 2.3
	of [RFC791].

	Other than the special rules for handling fragments and path MTU
	discovery, the actual translation of the packet header consists of a
	simple translation as defined below.

Not a requirement.

	Note that ICMPv6 packets
	require special handling in order to translate the contents of ICMPv6
	error messages and also to remove the ICMPv6 pseudo-header checksum.

	The translator SHOULD make sure that the packets belonging to the
	same flow leave the translator in the same order in which they
	arrived.

Untestable.

### 5.1. Translating IPv6 Headers into IPv4 Headers

Postponed.

### 5.1.1. IPv6 Fragment Processing

Postponed.

### 5.2. Translating ICMPv6 Headers into ICMPv4 Headers

	If a non-checksum-neutral translation address is being used, ICMPv6
	messages MUST have their ICMPv4 checksum field be updated as part of
	the translation since ICMPv6 (unlike ICMPv4) includes a pseudo-header
	in the checksum just like UDP and TCP.

Untestable.

	In addition, all ICMP packets MUST have the Type translated and, for
	ICMP error messages, the included IP header MUST also be translated.

Too trivial.

	<Rest>

Postponed.

### 5.3. Translating ICMPv6 Error Messages into ICMPv4

	There are some differences between the ICMPv4 and the ICMPv6 error
	message formats as detailed above.  The ICMP error messages
	containing the packet in error MUST be translated just like a normal
	IP packet (except that the TTL/Hop Limit value of the inner IPv4/IPv6
	packet are not decremented).  The translation of this "packet in
	error" is likely to change the length of the datagram; thus, the
	Total Length field in the outer IPv4 header MUST be updated.

I don't think there's a situation in which the translation of the inner ICMP error will not change the size of the overall datagram.

All of these tests are ICMPv6 error containing IPv6 packet -> ICMPv4 error (TTL - 1) containing IPv4 packet (TTL - 0):<br />
Test: ICMPv6 error sized 400 (40 + 8 + 40 + 312) -> ICMPv4 error sized 360 (20 + 8 + 20 + 312) (normal case) ([bd](#bd))<br />
Test: ICMPv6 error sized 700 (40 + 8 + 40 + 612) -> ICMPv4 error sized 576 (20 + 8 + 20 + 528) (result truncated due to ICMP fragmentation preventer) ([be](#be))

	The translation of the inner IP header can be done by invoking the
	function that translated the outer IP headers.  This process MUST
	stop at the first embedded header and drop the packet if it contains
	more embedded headers.

Test: ICMPv6 error containing ICMPv6 error. (Untestable; ICMP errors do not yield different ICMP errors.)

### 5.4. Generation of ICMPv6 Error Messages

	If the IPv6 packet is discarded, then the translator SHOULD send back
	an ICMPv6 error message to the original sender of the packet, unless
	the discarded packet is itself an ICMPv6 message.

	The ICMPv6 message MUST have Type 1 (Destination Unreachable) and
	Code 1 (Communication with destination administratively prohibited),
	unless otherwise specified in this document or [RFC6146].  The
	translator SHOULD allow an administrator to configure whether the
	ICMPv6 error messages are sent, rate-limited, or not sent.

Off a quick `Ctrl+F`, this is the only unspecified ICMPv6 error:

	Total Length:  If the Next Header field of the Fragment Header is an
	extension header (except ESP, but including the Authentication
	Header (AH)), then the packet SHOULD be dropped and logged.

Test: Extension header after Fragment -> ICMP error ([ac](#ac))

### 5.5. Transport-Layer Header Translation

	If the address translation algorithm is not checksum neutral (see
	Section 4.1 of [RFC6052]), the recalculation and updating of the
	transport-layer headers that contain pseudo-headers need to be
	performed.  Translators MUST do this for TCP, UDP, and ICMP.

Untestable.

	Other transport protocols (e.g., DCCP) are OPTIONAL to support.  In
	order to ease debugging and troubleshooting, translators MUST forward
	all transport protocols as described in the "Protocol" step of
	Section 5.1.

Test: IPv6 containing garbage transport -> IPv4 containing garbage transport ([fa](#fa))

### 5.6. Knowing When to Translate

	If the IP/ICMP translator also provides a normal forwarding function,
	and the destination address is reachable by a more specific route
	without translation, the router MUST forward it without translating
	it.  When an IP/ICMP translator receives an IPv6 datagram addressed
	to an IPv6 address representing a host in the IPv4 domain, the IPv6
	packet MUST be translated to IPv4.

Untestable.

## Part 2: Tests

rfc7915#section-1:

	Note when
	translating ICMPv4 Error Messages into ICMPv6, the "illegal"
	source address will be translated for the purpose of trouble
	shooting.

Graybox:

	Section 4.1:
		DF unset -> fragmented to 1280 (redundant)
		DF set, packet to big -> Fragmentation needed (redundant)
		<Fields here. They were mostly tested in the other sections above.>
	Section 4.2:
		<Mostly just fields>
	Section 4.3:
		Como que no hay una prueba donde cheques que length del ICMP error externo se afecta por el cambio de tamaño del interno. La que hay es truncada por el límite de ICMP.


	UDP checksum zero 4->6
	Paquete con unknown L4 protocol

Glossary:

- "X must not be translated": "The translator must pretend that X does not exist, and continue translation normally."
- "X must be ignored": Same as "X must not be translated."
- "X must be dropped": "X is a packet, and must be eliminated without response nor translation."
- "X must be rejected": "X is a packet, and must be eliminated without translation, but the source must be informed of this event by way of an ICMP error."

## Extra Header Baggage Tests

See [Simple Extension Headers](https://github.com/NICMx/Jool/wiki/RFC-7915-Review#simple-extension-headers).

### aa

- Requirement: Jool _must not translate_ any IPv4 options found in the original packet.
- Test packets:
	1. IPv4 without IPv4 options.
	2. `test-1` plus IPv4 options.
- Expected packets:
	1. Simple IPv6 (no extension headers).
- Validation: Both `test-1` and `test-2` must translate into `expected-1`.

### ab

- Requirement: Jool _must not translate_ any SEHs found before the Fragment Header.<br />
  Note: If there is no Fragment Header, behavior is undefined. In these cases, Jool treats all SEHs as "before Fragment" SEHs.
- Test packets:
	1. IPv6 packet with no extension headers.
	2. `test-1` plus SEHs.
	3. `test-2` plus a Fragment Header after the SEHs.
- Expected packets:
	1. Unfragmented IPv4 packet.
	2. Fragmented IPv4 packet.
- Validation: `test-1` and `test-2` must yield `expected-1`, `test-3` must yield `expected-2`.

> TODO Missing tests for extension headers that yield undefined behavior (such as No Next Header)

### ac

- Requirement: Jool must _reject_ packets containing SEHs after the Fragment Header.
- Test packets:
	1. IPv6 packet with Fragment Header, then a Hop-by-Hop extension header.
	2. IPv6 packet with Fragment Header, then a Destination Options extension header.
	3. IPv6 packet with Fragment Header, then a Routing extension header.
	4. IPv6 packet with a Hop-by-Hop extension header, then a Fragment Header, then a Hop-by-Hop extension header.
	5. IPv6 packet with a Destination Options extension header, then a Fragment Header, then a Destination Options extension header.
	6. IPv6 packet with a Routing extension header, then a Fragment Header, then a Routing extension header.
- Expected packets:
	1. ICMPv6 1/1 error containing `test-1`.
	2. ICMPv6 1/1 error containing `test-2`.
	3. ICMPv6 1/1 error containing `test-3`.
	4. ICMPv6 1/1 error containing `test-4`.
	5. ICMPv6 1/1 error containing `test-5`.
	6. ICMPv6 1/1 error containing `test-6`.
- Validation: `test-n` must yield `expected-n`.

The RFC states that these packets "SHOULD be dropped and logged," which seemingly implies that the default ICMP error from [section 5.4](https://tools.ietf.org/html/rfc7915#section-5.4) is supposed to kick in.

## ICMP Error Tests

### ba

- Requirements:
	1. When translating an ICMPv4 error, the internal packet must also be translated.
	2. Outer TTL must be decremented, inner TTL must not.
- Test packets:
	1. ICMPv4 error sized 400 (20 + 8 + 20 + 352)
- Expected packets:
	1. ICMPv6 error (TTL - 1) sized 440 (40 + 8 + 40 + 352)
- Validation: `test-1` must yield `expected-1`.

### bb

- Requirements:
	1. If an ICMPv4 error's internal packet is truncated during translation, the external packet's total length must reflect this.
	2. Outer TTL must be decremented, inner TTL must not.
	3. ICMPv6 errors must length 1280 bytes at most, to maximize delivery probability.
- Test packets:
	1. ICMPv4 error sized 1500 (20 + 8 + 20 + 1452)
- Expected packets:
	1. ICMPv6 error (TTL - 1) sized 1280 (40 + 8 + 40 + 1192)
- Validation: `test-1` must yield `expected-1`.

## bc

- Requirement: Same as the previous one, except the packet size does not change.
- Test packets:
	1. ICMPv4 error sized 1280 (20 + 8 + 20 + 1232)
- Expected packets:
	1. ICMPv6 error (TTL - 1) sized 1280 (40 + 8 + 40 + 1192)
- Validation: `test-1` must yield `expected-1`.

This is just an edge case, and it's probably pointless.

## bd

- Requirements:
	1. When translating an ICMPv6 error, the internal packet must also be translated.
	2. Outer TTL must be decremented, inner TTL must not.
- Test packets:
	1. ICMPv6 error sized 400 (40 + 8 + 40 + 312)
- Expected packets:
	1. ICMPv4 error (TTL - 1) sized 360 (20 + 8 + 20 + 312)
- Validation: `test-1` must yield `expected-1`.

## be

- Requirements:
	1. If the internal packet is truncated, the external packet's total length must reflect this.
	2. Outer TTL must be decremented, inner TTL must not.
	3. ICMPv4 errors must length 576 bytes at most, to maximize delivery probability.
- Test packets:
	1. ICMPv6 error sized 700 (40 + 8 + 40 + 612)
- Expected packets:
	1. ICMPv4 error sized 576 (20 + 8 + 20 + 528)
- Validation: `test-1` must yield `expected-1`.

## Atomic Fragment Deprecation Tests

### ca

- Requirement: If an IPv4 packet has DF enabled and is too large, Jool must return Fragmentation Needed.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1261
- Test Packets:
	1. IPv4 packet (TCP or UDP), DF enabled, size 1261.
- Expected packets:
	1. Fragmentation Needed containing `test-1`, size 576.
- Validation: `test-1` must yield `expected-1`.

### cb

- Requirement: If an IPv4 packet has DF enabled but it's small enough, translation must succeed.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1260.
- Test packets:
	1. IPv4 packet (TCP or UDP), DF enabled, size 1260.
- Expected packets:
	1. IPv6 packet, no fragment header, size 1280
- Validation: `test-1` must yield `expected-1`.

### cc

- Requirement: If an IPv4 packet has DF disabled and it's too large, Jool must fragment.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1261
- Test packets:
	1. IPv4/TCP packet, DF disabled, size 1261. (20 + 20 + 1221)
- Expected packets:
	1. IPv6 fragment, size 1280 (40 + 8 + 20 + 1212)
	2. IPv6 fragment, size 57 (40 + 8 + 9)
- Validation: `test-1` must yield both `expected-1` and `expected-2`.

### cd

- Requirement: If an IPv4 packet has DF disabled and it's small enough, translation must succeed.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1260
- Test packets:
	1. IPv4 packet (TCP or UDP), DF disabled, size 1260.
- Expected packets:
	1. IPv6 packet, no fragment header, size 1280.
- Validation: `test-1` must yield `expected-1`.

### ce

- Requirement: Small IPv4 fragment must yield an IPv6 fragment with the same identification number.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1260
- Test packets:
	1. IPv4/TCP fragment, size 1260
- Expected packets:
	2. IPv6 fragment, size 1280 (same ID)
- Validation: `test-1` must yield `expected-1`.

### cf

- Requirement: Large IPv4 fragment must yield multiple IPv6 fragments with the same identification number.
- Environment: IPv6 MTU = 1280, IPv4 MTU >= 1261
- Test packets:
	1. IPv4/TCP fragment, size 1261 (20 + 20 + 1221)
- Expected packets:
	1. IPv6 fragment, size 1280 (40 + 8 + 20 + 1212), same ID
	2. IPv6 fragment, size  57 (40 + 8 + 9), same ID
- Validation: `test-1` must yield `expected-1` and `expected-2`.

### cg

- Requirement: Overly large IPv6 packet must yield a Packet too Big.
- Environment: IPv6 MTU >= 1421, IPv4 MTU = 1400
- Test packets:
	1. IPv6 packet, size 1421
- Expected packets:
	1. Packet too Big containing `test-1`, size 1280.
- Validation: `test-1` must yield `expected-1`.

### ch

- Requirement: Large IPv6 packet must yield DF enabled.
- Environment: IPv6 MTU >= 1281, IPv4 >= 1261
- Test packets:
	1. IPv6 packet, size 1281
- Expected packets:
	1. IPv4 packet, size 1261, DF enabled
- Validation: `test-1` must yield `expected-1`.

### ci

- Requirement: Small IPv6 packet must yield DF disabled.
- Environment: IPv6 MTU >= 1280, IPv4 MTU >= 1260
- Test packets:
	1. IPv6 packet, size 1280
- Expected packets:
	1. IPv4 packet, size 1260, DF disabled
- Validation: `test-1` must yield `expected-1`.

## Forwarding Path MTU Discovery Tests

Non-forwarding PMTUD tests were already included in the previous section.

### da

- Requirement: Packet too Big should become Fragmentation Needed, with MTU adjusted.
- Environment: IPv6 MTU > 1280, IPv4 MTU > 1300
- Test packets:
	1. Packet too Big, MTU = 1280
- Expected packets:
	1. Fragmentation Needed, MTU = 1300
- Validation: `test-1` must yield `expected-1`.

### db

- Requirement: Fragmentation Needed should become Packet too Big, with MTU adjusted. IPv6 MTU must not go below 1280.
- Test packets:
	1. Fragmentation Needed, MTU = 1301
	2. Fragmentation Needed, MTU = 1300
	3. Fragmentation Needed, MTU = 1299
- Expected packets:
	1. Packet too Big, MTU = 1281
	2. Packet too Big, MTU = 1280
- Validation: `test-1` must yield `expected-1`, `test-2` and `test-3` must yield `expected-3`.

## Zero UDP Checksum Tests

### ea

- Requirement: If `amend-udp-checksum-zero` is disabled, an unfragmented UDP packet with checksum = 0 must be _rejected_.
- Environment: Disable `amend-udp-checksum-zero` configuration option.
- Test packets:
	1. IPv4/UDP packet, UDP checksum = 0
- Expected packets:
	1. ICMP error
- Validation: `test-1` must yield `expected-1`.

### eb

- Requirement: If `amend-udp-checksum-zero` is enabled, an unfragmented UDP packet with checksum = 0 must be translated, its checksum computed from scratch.
- Environment: Enable `amend-udp-checksum-zero` configuration option.
- Test packets:
	1. IPv4/UDP packet, UDP checksum = 0
- Expected packets:
	1. IPv6/UDP packet
- Validation: `test-1` must yield `expected-1`.

### ec

- Requirement: Fragmented UDP packets with checksum = 0 must be _rejected_.
- Test packets:
	1. IPv4/UDP fragment (fragment offset = 0), UDP checksum = 0
- Expected packets:
	1. ICMP error
- Validation: `test-1` must yield `expected-1`.

## Unknown Transport Protocols Tests

### fa

- Requirement: Unknown transport protocols should be copied as-is.
- Test packets:
	1. IPv4/DCCP packet
	2. IPv6/DCCP packet (payload identical to `test-1`)
- Validation: `test-1` must yield `test-1`, `test-2` must yield `test-1`.

## Hairpinning Tests

### ga

TODO
